#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  rightEncode,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncode,     sensorQuadEncoder)
#pragma config(Motor,  port1,           topLeft,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           topRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           botLeft,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           botRight,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           frontRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           backRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           frontLeft,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           belt,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
Mecanum Drive - Basic
- This program allows you to remotely control a robot with mecanum wheels.
- The left joystick Y-axis controls the robot's forward and backward movement.
- The left joystick X-axis controls the robot's left and right movement.
- The right joystick X-axis controls the robot's rotation.

[I/O Port]          [Name]              [Type]                [Description]
Motor Port 2        frontRight          VEX Motor             Front Right motor
Motor Port 3        backRight           VEX Motor             Back Right motor
Motor Port 4        frontLeft           VEX Motor             Front Left motor
Motor Port 5        backLeft            VEX Motor             Back Left motor
----------------------------------------------------------------------------------------------------*/

task LCD()
{
	/*int time;
	int second = 0;
	int minute = 0;
	string timer = "";
	string minutest = "";
	string secondst = "";
	string milist = "";
	clearTimer(timer4);
	while(true)
	{
	time = time1[T4];

	if(time >= 1000)
	{
	second = second + 1;
	clearTimer(timer4);
	}

	if(second == 60)
	{
	minute = minute + 1;
	second = 0;
	}
	minutest = (string)minute;
	milist = (string)time;
	secondst = (string)second;
	timer = minutest + ":" + secondst + ":" + milist;
	displayLCDCenteredString(0,"Auton 1");

	}
	*/
}


task main()
{
	clearTimer(timer4);
	startTask(LCD);
	int x_d;
	int x_r;
	int y_d;
	int threshold = 15;
	int lift = 90;
	int convey = 90;
	int correct;
	int cubes = 0;
	clearTimer(timer1);
	bool toggle1 = false;
	int toggletime = 200;
	bool togglecheck = false;

	while(true)
	{
		x_d = vexRT[Ch4];
		x_r = vexRT[Ch1];
		y_d = vexRT[Ch3];

		if (time1[timer1] >= toggletime)
		{
			togglecheck = true;
			clearTimer(timer1);
		}
		if (togglecheck == true)
		{
			if (vexRT[Btn8U] == 1)
			{
				if (toggle1 == false) toggle1 = true;
			}
			else if(vexRT[Btn6D] == 1)
			{
				if (toggle1 == true) toggle1 = false;
			}
		}


		if(abs(x_d) < threshold) x_d = 0;
		if(abs(x_r) < threshold) x_r = 0;
		if(abs(y_d) < threshold) y_d = 0;

		if(vexRT[Btn5U] == 1)
		{
			motor[topLeft] = lift;
			motor[topRight] =  lift;
			motor[botLeft] = lift;
			motor[botRight] =  lift;
		}
		else if(vexRT[Btn5D] == 1)
		{
			motor[topLeft] = lift * -1;
			motor[topRight] =  lift * -1;
			motor[botLeft] = lift * -1;
			motor[botRight] =  lift * -1;
		}
		else
		{
			motor[topLeft] = 0;
			motor[topRight] =  0;
			motor[botLeft] = 0;
			motor[botRight] =  0;
		}

		if(vexRT[Btn8L] == 1) cubes = 0;
		if(vexRT[Btn8D] == 1) cubes = 1;
		if(vexRT[Btn8R] == 1) cubes = 2;

		if (toggle1 == true)
		{
			if(vexRT[Btn6U] == 1)
			{
				if(cubes == 0) motor[belt] = 0;
				if(cubes == 1) motor[belt] = 10;
				if(cubes == 2) motor[belt] = 20;
			}
			else
			{
				if(vexRT[Btn6U] == 1)
				{
					motor[belt] = convey;
				}
				else if(vexRT[Btn6D] == 1)
				{
					motor[belt] = convey * -1;
				}
				else
				{
					if(cubes == 0) motor[belt] = 0;
					if(cubes == 1) motor[belt] = 10;
					if(cubes == 2) motor[belt] = 20;
				}
			}
		}
		else
		{
			if(vexRT[Btn6U] == 1)
			{
				motor[belt] = convey;
			}
			else if(vexRT[Btn6D] == 1)
			{
				motor[belt] = convey * -1;
			}
			else
			{
				if(cubes == 0) motor[belt] = 0;
				if(cubes == 1) motor[belt] = 10;
				if(cubes == 2) motor[belt] = 20;
			}
		}


		correct = x_d * .20;
		if(x_d > 0) x_r = x_r - correct;
		if(x_d < 0) x_r = x_r + correct;

		motor[frontRight] = y_d - x_r - x_d;
		motor[backRight] =  y_d - x_r + x_d;
		motor[frontLeft] = y_d + x_r + x_d;
		motor[backLeft] =  y_d + x_r - x_d;
	}
}
